#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <ctype.h>


typedef struct string_list_node {
	char *string;
	struct string_list_node *next;
} string_list_node_t;

typedef struct string_list {
	struct string_list_node *head;
	struct string_list_node *tail;
	struct string_list *next;
} string_list_t;

string_list_t *
string_list_alloc(void)
{
	string_list_t *lp;

	lp = malloc(sizeof (string_list_t));
	assert(lp != NULL);

	(void) bzero(lp, sizeof (string_list_t));
	return (lp);
}

string_list_node_t *
string_list_node_alloc(char *str)
{
	string_list_node_t *np;

	np = malloc(sizeof (string_list_node_t));
	assert(np != NULL);

	(void) bzero(np, sizeof (string_list_node_t));
	np->string = str;
	return (np);
}

void
string_list_destroy(string_list_t *pl)
{
	string_list_node_t *pn;
	string_list_node_t *next;

	assert(pl != NULL);

	pn = pl->head;

	while (pn != NULL) {
		next = pn->next;
		free(pn);
		pn = next;
	}
	free(pl);
}

void
string_list_insert_str(string_list_t *pl, char *str)
{
	string_list_node_t *pn;

	assert(pl != NULL && str != NULL);

	pn = string_list_node_alloc(str);

	if (pl->head == NULL && pl->tail == NULL) {
		pl->head = pl->tail = pn;
		return;
	}

	pl->tail->next = pn;
	pl->tail = pn;
}

void
string_list_print(string_list_t *pl)
{
	string_list_node_t *pn;

	assert(pl != NULL);

	for (pn = pl->head; pn != NULL; pn = pn->next)
		printf("%s  ", pn->string);

	printf("\n");
}

void
string_lists_print(string_list_t *pl)
{
	string_list_t *tmp;

	assert(pl != NULL);

	for (tmp = pl; tmp != NULL; tmp = tmp->next)
		string_list_print(tmp);
}

int
new_str(char *str, char **newstr)
{
	int len;
	char *ns;

	assert(str != NULL && newstr != NULL);


	/*
	 * Need to allocate 3 more bytes.  2 are needed for the new
	 * parantheses that we are about to add, plus 1 for the NULL
	 * terminator at the end.  STRLEN(3) does not include the NULL
	 * terminator as part of the string length.
	 */
	len = strlen(str) + 3;
	ns = malloc(len);

	assert(ns != NULL);
	(void) bzero(ns, len);

	*newstr = ns;
	return (len);
}

char *
p_outside(char *str)
{
	int len;
	char *newstr;

	assert(str != NULL);

	len = new_str(str, &newstr);
	snprintf(newstr, len, "(%s)", str);
	return (newstr);
}

char *
p_right(char *str)
{
	int len;
	char *newstr;

	assert(str != NULL);

	len = new_str(str, &newstr);
	snprintf(newstr, len, "%s()", str);
	return (newstr);
}

char *
p_left(char *str)
{
	int len;
	char *newstr;

	assert(str != NULL);

	len = new_str(str, &newstr);
	snprintf(newstr, len, "()%s", str);
	return (newstr);
}

string_list_t *
asshole_problem(int num)
{
	string_list_t *last;
	string_list_t *cur;
	string_list_t *prev;
	int i;

	if (num == 0)
		return (NULL);

	cur = string_list_alloc();
	string_list_insert_str(cur, p_outside(""));

	if (num == 1)
		return (cur);

	for (i = 1; i < num; i++) {
		string_list_node_t *pn;
		prev = cur;
		cur = string_list_alloc();

		for (pn = prev->head; pn != NULL; pn = pn->next) {
			string_list_insert_str(cur, p_left(pn->string));
			string_list_insert_str(cur, p_outside(pn->string));
			/*
			 * Adding a pair of parens on the right side of this
			 * this string would be no different than adding them
			 * to the left (which we already did above).  Example:
			 * If you have a string which looks like this:
			 *                  "()()"
			 * It should be pretty obvious that adding another set
			 * to the right side would generate the exact same
			 * string that we already generated by adding a pair
			 * to the left:
			 *                 "()()()"
			 * For that reason, we skip the right side operation.
			 * Because of the way the linked list is built out,
			 * the head node will always contain a string that
			 * must go through this test.  That is, the head will
			 * always have a string that looks like:
			 * "()", or "()()", or "()()()", or "()()()()".
			 */
			if (pn == prev->head)
				continue;

			string_list_insert_str(cur, p_right(pn->string));
		}

		/*
		 * This is no longer needed.  It will be set to `cur' at the
		 * top of the loop.  Either that or this is the final interation
		 * of the loop.  Regardless, we need to free `prev' as it is
		 * of no more use to us.
		 */
		string_list_destroy(prev);
	}

	return (cur);
}

int main(int argc, char **argv)
{
	int num;

	assert(argc == 2);

	num = atoi(argv[1]);

	string_list_t *list = asshole_problem(num);
	string_list_print(list);
	return (0);
}
